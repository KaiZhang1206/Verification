https://blog.csdn.net/gatieme/article/details/52557546

三者的最高位均为符号位.

我以前一直没弄明白的是为何8位补码的表示范围是-128~127, 今天查阅了相关资料，于此记下。

仍然以8位为例：

原码

原码的表示范围-127~-0, +0~+127, 共256个数字。

正0的原码是0000 0000, 负0的原码是1000 0000, 有正0负0之分, 不符合人的习惯, 待解决.

反码

除符号位, 原码其余位取反而得 
+0：0000 0000，-0：1111 1111 仍然有正0负0之分。

补码

在反码的基础上加1而得

对原码的两种0同时末位加1

+0：0000 0000，-0：0000 0000(因为溢出导致8位全0)

消除了正0负0之别, 如此一来, 便节省出一个数值表示方式1000 0000, 不能浪费, 用来表示-128, -128特殊之处在于没有相应的反码原码。也可以这样考虑:

-1：   1111 1111
-2：   1111 1110（在-1的基础上减1，直接将补码减1即可）
-3：   1111 1101（在-2补码基础上减1，以下类似）
-4：   1111 1100
……
-127：1000 0001
-128：1000 0000
1
2
3
4
5
6
7
如此以来：8位补码表示范围是-128~+127因为0只有一种形式所以，仍然是256个数

若8位代表无符号数, 则表示范围是 : 0~255, 这就是为什么高级语言讲到数据类型，

比如C++中的short类型时（16位长）说其表示范围是：-32768~+32767，而unsigned short表示的范围则是：0~65535
————————————————
版权声明：本文为CSDN博主「JeanCheng」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/gatieme/article/details/52557546
